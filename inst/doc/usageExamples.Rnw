\documentclass[article,nojss]{jss}


<<package,include=FALSE,echo=FALSE>>=
options(keep.source = TRUE, width = 60)
packageInfo <- packageDescription("ggbeeswarm")
library(ggbeeswarm)
packageKeywords<-"visualization, display, one dimensional, grouped, groups, violin, scatter, points, quasirandom, beeswarm, van der Corput, beeswarm, ggplot, ggplot2"
@
%\VignetteIndexEntry{vipor package usage examples}
%\VignetteDepends{}
%\VignetteKeywords{visualization, display, one dimensional, grouped, groups, violin, scatter, points, quasirandom, beeswarm, van der Corput, beeswarm, ggplot, ggplot2}
%\VignettePackage{vipor}

\title{\pkg{\Sexpr{packageInfo$Package}} package usage example (version \Sexpr{packageInfo$Version})}
\author{\Sexpr{packageInfo$Author}}
\Plainauthor{\Sexpr{packageInfo$Author}}

\Address{
  Github: \url{http://github.com/eclarke/ggbeeswarm}\\
  Cran: \url{https://cran.r-project.org/package=ggbeeswarm}
}

\Keywords{\Sexpr{packageKeywords}}

\Abstract{
  This is a collection of examples of usage for the \pkg{\Sexpr{packageInfo$Package}} package.
}

\begin{document}
\SweaveOpts{engine=R,eps=FALSE}

\section{The basics}

This is the simplest example of using \code{geom_quasirandom} to generate violin scatter plots:
<<ggPlot, echo=TRUE, eval=FALSE>>=
  library(ggbeeswarm)
  set.seed(12345)
  n<-100
  dat<-rnorm(n*2)
  labs<-rep(c('a','b'),n)
  ggplot(mapping=aes(labs, dat)) + geom_quasirandom()
@

\begin{center}
<<showGgPlot, fig=TRUE, height=3.5, width=5, echo=FALSE>>=
<<ggPlot>>
@
\end{center}


Normal \code{ggplot} options can be used:
<<ggOpts, echo=TRUE, eval=FALSE>>=
  ggplot(mapping=aes(labs, dat)) + geom_quasirandom(aes(color=labs))
@

\begin{center}
<<showGgOpts, fig=TRUE, height=3.5, width=5, echo=FALSE>>=
<<ggOpts>>
@
\end{center}

Factors can be used to generate custom group orderings:
<<ggFactors, echo=TRUE, eval=FALSE>>=
  labs2<-factor(labs,levels=c('b','a'))
  ggplot(mapping=aes(labs2, dat)) + geom_quasirandom(aes(color=labs))
@
\begin{center}
<<showGgFactors, fig=TRUE, height=3.5, width=5, echo=FALSE>>=
<<ggFactors>>
@
\end{center}

\section{Options}
\code{quasirandom} calls \code{vipor::offsetX} which calls \code{stats::density} to compute kernel density estimates. The tightness of the fit can be adjusted with the \code{adjust} option and the width of the offset with \code{width}. \code{nbins} to adjust the number of bins used in the kernel density is also provided but this can usually be left at its default when using quasirandom offsets but is useful for non-quasirandom methods:

<<distAdjust, echo=TRUE, eval=FALSE, tidy=TRUE>>=
  library(gridExtra)
  dat <- list(
    'Normal'=rnorm(50),
    'Dense normal'= rnorm(500),
    'Bimodal'=c(rnorm(100), rnorm(100,5)),
    'Trimodal'=c(rnorm(100), rnorm(100,5),rnorm(100,-3))
  )
  labs<-rep(names(dat),sapply(dat,length))
  labs<-factor(labs,levels=unique(labs))
  dat<-unlist(dat)
  p1<-ggplot(mapping=aes(labs, dat)) + geom_quasirandom(bandwidth=2,alpha=.2) +
    ggtitle('bandwidth=2') + labs(x='')
  p2<-ggplot(mapping=aes(labs, dat)) + geom_quasirandom(bandwidth=.1,alpha=.2) +
    ggtitle('bandwidth=.1') + labs(x='') 
  p3<-ggplot(mapping=aes(labs, dat)) + geom_quasirandom(width=.1,alpha=.2) +
    ggtitle('width=.1') + labs(x='')
  p4<-ggplot(mapping=aes(labs, dat)) + geom_quasirandom(nbins=100,alpha=.2) +
    ggtitle('nbins=100') + labs(x='')
  grid.arrange(p1, p2, p3, p4, ncol=1)
@
\begin{center}
<<showDistAdjust, fig=TRUE, height=8, width=6, echo=FALSE>>=
<<distAdjust>>
@
\end{center}

The \code{varwidth} argument scales the width of a group by the square root of the number of observations in that group (as in the function \code{boxplot}):
<<varwidth, echo=TRUE, eval=FALSE>>=
  dat <- list(
    '10 points'=rnorm(10),
    '50 points'=rnorm(50,2),
    '200 points'=c(rnorm(400), rnorm(100,5)),
    '5000 points'= rnorm(5000,1)
  )
  labs<-rep(names(dat),sapply(dat,length))
  labs<-factor(labs,levels=unique(labs))
  dat<-unlist(dat)
  ggplot(mapping=aes(labs, dat)) + geom_quasirandom(varwidth=TRUE)
@
\begin{center}
<<showVarwidth, fig=TRUE, height=4, width=6, echo=FALSE>>=
<<varwidth>>
@
\end{center}

%\section{Real data}
%An example using the \code{beaver1} and \code{beaver2} data from the \pkg{datasets} package:
%<<vpBeaver, echo=TRUE, eval=FALSE>>=
%  y<-c(beaver1$temp,beaver2$temp)
%  x<-rep(
%    c('Beaver 1','Beaver 2'),
%    c(nrow(beaver1),nrow(beaver2))
%  )
%  vpPlot(x,y,las=1, ylab='Body temperature',
%    pch=21, col='#00000099',bg='#00000033')
%@
%\begin{center}
%<<showBeaver, fig=TRUE, height=4, width=4, echo=FALSE>>=
%<<vpBeaver>>
%@
%\end{center}
%
%An example using the \code{integrations} data from this package:
%<<vpGene, echo=TRUE, eval=FALSE>>=
%  ints<-integrations[integrations$nearestGene>0,]
%  y<-log(ints$nearestGene)
%  x<-as.factor(paste(ints$study,ints$latent))
%  activeCols<-c('Expressed'='#FF000033','Unexpressed'='#0000FF33')
%  cols<-activeCols[ints$latent]
%  par(mar=c(4,7,.1,.1))
%  vpPlot(x,y,las=2, ylab='Log distance to gene',xaxt='n',
%    pch=21, col=cols,bg=cols,cex=.7)
%  uniqX<-levels(x)
%  prettyX<-tapply(1:length(uniqX),sub('(Une|E)xpressed$','',uniqX),mean)
%  axis(1,prettyX,names(prettyX),las=2)
%  legend(grconvertX(0.01,from='ndc'),grconvertY(0.15,from='ndc'),
%    names(activeCols),pch=21,col=cols,pt.bg=activeCols,xpd=NA)
%@
%\begin{center}
%<<showGene, fig=TRUE, height=4, width=6, echo=FALSE>>=
%<<vpGene>>
%@
%\end{center}
%
%\section{ggbeeswarm package}
%This package is also wrapped by the \pkg{ggbeeswarm} package so if you prefer \code{ggplot} then you can do something like:
%<<ggPlot, echo=TRUE, eval=FALSE>>=
%  library(ggbeeswarm)
%  n<-100
%  dat<-rnorm(n*2)
%  labs<-rep(c('a','b'),n)
%  ggplot(mapping=aes(labs,dat))+geom_quasirandom()
%@
%\begin{center}
%<<showGg, fig=TRUE, height=4, width=6, echo=FALSE>>=
%<<ggPlot>>
%@
%\end{center}


\end{document}
